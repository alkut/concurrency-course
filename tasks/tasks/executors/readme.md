# Executors

## Пререквизиты

- [tasks/thread-pool](/tasks/tasks/thread-pool)
- [fibers/yield](/tasks/fibers/yield)

## Декомпозиция

_Futures_, _stackful fibers_, _stackless coroutines_ – это _выразительные средства_, с помощью которых разработчик описывает конкурентные активности в своем приложении.

Для разработчика эти средства существенно отличаются друг от друга. А для _среды исполнения_ (пула потоков) они, наоборот, выглядят одинаково – как цепочки неблокирующихся задач.

Конкурентность декомпозирована:
- _Выразительные средства_ _описывают_ цепочки задач
- _Среда исполнения_ _исполняет_ эти цепочки

## Абстракция

В этой задаче мы абстрагируем среду исполнения: фьючи, файберы и корутины будут запускать свои задачи не в конкретном пуле потоков, а в абстрактном _экзекуторе_.

## Executor

_Executors are to function execution as allocators are to memory allocation_

_Экзекутор_ (_executor_) – это сервис, исполняющий задачи. 

Экзекутор реализует интерфейс [`IExecutor`](exe/executors/executor.hpp) с единственным методом `Submit` – запланировать задачу на исполнение.

Единственная гарантия, которую экзекутор дает своему пользователю: _запланированная в него задача будет исполнена_.

В каком потоке и когда именно – зависит от конкретной реализации интерфейса `IExecutor`. Механика исполнения задач скрыта от пользователя за виртуальным вызовом.

## Дизайн

- _Выразительные средства_ (фьючи, файберы, корутины) описывают _что_ исполнять
- _Экзекуторы_ (`ThreadPool`, `ManualExecutor`, `Strand`) – _как_ исполнять
- `IExecutor` – граница, разделяющая выразительные средства и конкретные стратегии исполнения задач

## Реализации

### Пул потоков

[`ThreadPool`](exe/executors/tp/compute/thread_pool.hpp) – статический набор потоков-воркеров, разбирающих общую очередь задач.

```cpp
void ThreadPoolExample() {
  using namespace exe;
  
  // ThreadPool реализует интерфейс IExecutor
  executors::ThreadPool pool{/*threads=*/4};
  pool.Start();
  
  executors::Submit(pool, [] {
    fmt::println("Running on thread pool");
  });
  
  // Дожидаемся завершения всех задач
  pool.WaitIdle();
  // Останавливаем пул
  pool.Stop();
}
```

#### Применение

Мы уже использовали пул потоков как планировщик для файберов:

```cpp
void FibersExample() {
  using namespace exe;
  
  executors::ThreadPool pool{4};
  pool.Start();

  // Функция Go теперь принимает IExecutor&
  fibers::Go(/*executor=*/pool, [] {
    for (size_t i = 0; i < 7; ++i) {
      fibers::Yield();
    }
  });
  
  pool.WaitIdle();
  pool.Stop();
}
```

Класс `Fiber` не знает в каком именно экзекуторе его запустили.

Реализация файберов должна полагаться только на абстракцию `IExecutor` и на базовую гарантию, которую эта абстракция предоставляет.

### Manual

[`ManualExecutor`](exe/executors/manual.hpp) – это всего лишь очередь задач, собственных потоков у него нет.

Вызов `Submit` добавляет задачу в конец этой очереди.

Задачи, запланированные в `ManualExecutor`, запускаются **вручную** с помощью методов `RunNext`, `RunAtMost` и `Drain`.

С `ManualExecutor` должен работать только один поток.

#### Пример

```cpp
void ManualExample() {
  using namespace exe;
  
  // ManualExecutor – очередь задач
  executors::ManualExecutor manual;
  
  // Добавляем задачу в очередь
  executors::Submit(manual, [] {
    fmt::println("1st");
  });
  
  // И еще одну
  executors::Submit(manual, [] {
    fmt::println("2nd");
  });

  // <-- Теперь обе задачи находятся в очереди ManualExecutor-а,
  // пока ни одна из них не была запущена

  // Запустим первую задачу
  manual.RunNext();

  // Запланируем третью задачу
  executors::Submit(manual, [] {
    fmt::println("3rd");
  });

  // "Опустошаем" очередь задач, т.е.
  // исполняем задачи до тех пор, пока очередь не опустеет
  manual.Drain();
  // <-- К этому моменту выполнились все три задачи
}
```

#### Применение

С помощью `ManualExecutor` файберы можно исполнять **детерминированно**, по шагам, что позволяет писать для них *детерминированные юнит-тесты*:

```cpp
void ManualFibers() {
  using namespace exe;
  
  // "Ручной" планировщик
  executors::ManualExecutor scheduler;
  
  fibers::Go(scheduler, [] {
    fibers::Yield();
  });

  fibers::Go(scheduler, [] {
    fibers::Yield();
  });
  
  // <-- Пока ни один файбер не начал исполняться
  
  // Первый шаг первым файбером
  scheduler.RunNext();
  // <-- Первый файбер зашел в `Yield`
  
  // Первый шаг вторым файбером
  scheduler.RunNext();
  // <-- Второй файбер зашел в `Yield`
  
  scheduler.Drain();
}
```

Вносить изменения в файберы при этом не требуется!

### Strand

#### Проблема

Задачам в пуле потоков может понадобиться взаимное исключение.

Использовать непосредственно мьютексы нежелательно: если задача в пуле захватила мьютекс на продолжительное время, то другие задачи, которым нужен этот же мьютекс, заблокируют потоки пула и помешают исполняться другим задачам, которым этот мьютекс вообще не нужен.

#### Асинхронный мьютекс

Экзекуторы предоставляют альтернативу: _асинхронный мьютекс_ или `Strand`.

[`Strand`](exe/executors/strand.hpp) – экзекутор, запускающий задачи (можно назвать их критическими секциями) строго **последовательно**, в порядке их планирования (вообще говоря, этот порядок частичный – _happens-before_).

Планировать задачи в `Strand` можно из разных потоков без внешней синхронизации.

#### Декоратор

`Strand` не имеет собственных потоков. `Strand` – декоратор, он оборачивает произвольный экзекутор и делегирует исполнение задач ему.

`Strand` не делает никаких предположений об устройстве декорируемого экзекутора. Единственная гарантия, на которую `Strand` полагается, – каждая запланированная
в декорируемый экзекутор задача однажды будет выполнена.

Один и тот же пул потоков могут использовать для исполнения произвольное число `Strand`-ов.

#### Пример

```cpp
void StrandExample() {
  using namespace exe::executors;
  
  // Потоки, исполняющие задачи
  ThreadPool workers{4};
  // Декоратор над пулом потоков `workers`
  // Сам `strand` не знает, что он декорирует именно пул потоков
  Strand strand{workers};
  
  ThreadPool clients{5};
  
  size_t cs = 0;
  
  // Запускаем в пуле `clients` задачи, которые будут
  // параллельно планировать критические секции в `strand`
  
  for (size_t i = 0; i < 1024; ++i) {
    Submit(clients, [&] {
      // Следующий `Submit` вызывается из разных потоков пула `clients`
      Submit(strand, [&] {
        // Асинхронная критическая секция
        ++cs;
      });
    });
  }
  
  // Ждем завершения клиентов
  clients.WaitIdle();
  // Ждем завершения инкрементов
  workers.WaitIdle();
  
  fmt::println("# critical sections: {}", cs);
  // <-- Напечатано 1024
  
  clients.Stop();
  workers.Stop();
}
```

#### `Strand` и мьютекс

##### Мьютекс

С точки зрения протокола когерентности кэшей, синхронный мьютекс – неэффективный примитив синхронизации:

Чем больше число ядер / потоков, исполняющих критические секции, тем выше накладные расходы на когерентность, так как разделяемые данные, к которым обращаются критические секции, придется постоянно двигать между ядрами.

##### Strand

Гораздо разумнее не данные двигать к критическим секциям на разные ядра, а наоборот – критические секции перенести на одно ядро.

Это и будет делать `Strand`. Чем больше будет нагрузка на `Strand`, тем _меньше_ будет в исполнении синхронизации, и тем эффективнее будут исполняться критические секции пользователей (в отличие от обычного мьютекса, в котором все наоборот)!

## Задание

1) Перенесите в [executors/tp/compute](exe/executors/tp/compute) реализацию пула потоков
2) Реализуйте [`ManualExecutor`](exe/executors/manual.hpp)
3) Реализуйте [`Strand`](exe/executors/strand.hpp) используя взаимное исключение
4) Реализуйте [`Strand`](exe/executors/strand.hpp) через лок-фри очередь 


## Реализация

### `Strand`

#### Серии

`Strand` должен исполнять задачи _сериями_ или _пакетами_ (_batching_).

1) Серийность позволит избавиться от синхронизации между критическими секциями при исполнении серии.
2) Критические секции внутри серии будут работать над прогретым кэшом.

Серии должны адаптироваться под нагрузку:

- Чем больше нагрузка на `Strand`, тем больше должны быть серии, и тем меньше должно быть синхронизации в исполнении.
  - Серии могут получаться сколь угодно большими, но все же должны оставаться конечными.
- При этом `Strand` не должен искусственно задерживать исполнение задач.

#### Lock-Free

Простая реализация `Strand` будет использовать взаимное исключение для доступа к очереди задач.

Избавьтесь от взаимного исключения: храните задачи `Strand`-а в лок-фри очереди. Вам пригодится умение строить очередь из двух стеков.

Продумайте управление памятью в вашей реализации.

Если вы все сделали правильно, то реализация лок-фри очереди для `Strand` получится очень простой.

### Интрузивность

Бонусный уровень<sup>†</sup>!

Избавьтесь от динамических аллокаций памяти в экзекуторах, сделав задачи интрузивными:

```cpp
struct ITask {
  virtual ~ITask() = default;
  
  virtual void Run() noexcept = 0;
};

struct TaskBase : ITask, wheels::IntrusiveListNode<TaskBase> {
  //
};
```

Метод `Submit` у `IExecutor` будет принимать `TaskBase*`: 

```cpp
struct IExecutor {
  virtual ~IExecutor() = default;
  
  virtual void Submit(TaskBase* task) = 0;
};
```

За аллокацию памяти для задачи должен отвечать пользователь экзекутора:
- Ни stackful файберам, ни фьючам, ни stackless корутинам динамические аллокации при планировании задач не требуются.
- Для лямбд выполняйте динамическую аллокацию в функции [`Submit`](exe/executors/submit.hpp).

†: Бонусный для этой задачи, а для хорошего рантайма – обязательный.

## Мьютекс для файберов

В этой задаче вы реализуете _асинхронный серийный лок-фри_ мьютекс.

А теперь вспомним, что файберы с помощью переключения контекста могут превращать асинхронные интерфейсы в синхронные.

Воспользуйтесь этим наблюдением и реализуйте для файберов _синхронный серийный лок-фри_ мьютекс в задаче [`fibers/mutex`](/tasks/fibers/mutex).
