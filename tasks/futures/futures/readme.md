# Futures

## Пререквизиты

- [condvar/future](/tasks/condvar/future)
- [futures/executors](/tasks/futures/executors)

---

## Канал

В первом и очень грубом приближении `Future` / `Promise` реализуют канал для возврата результата из асинхронной операции.

- `Promise<T>` – конец канала для записи, через него поток-_продьюсер_ отправляет результат,
- `Future<T>` – конец канала для чтения, через него поток-_консьюмер_ поглощает асинхронный результат.
- `Result<T>` – контейнер, содержащий либо значение типа `T`, либо ошибку.

### Пример
```cpp
executors::ThreadPool pool{4};

// Разворачиваем канал, создаем "контракт" на передачу результата
auto [f, p] = futures::MakeContract<int>();

// Запускаем асинхронную операцию
executors::Execute(pool, [p = std::move(p)]() {
  // Отправляем значение
  // В общем случае – отправляем результат через Set(Result<T>)
  std::move(p).SetValue(7);
});

// "Распаковываем" фьючу, "поглощаем" ее результат 
// Обратите внимание: GetResult – не метод Future, а внешняя функция
wheels::Result<int> result = futures::GetResult(std::move(f));

fmt::println("Value = {}", result.ValueOrThrow());
```

### `Result`

Результат асинхронной операции передается в виде [`wheels::Result<T>`](https://gitlab.com/Lipovsky/wheels/-/blob/master/wheels/support/result.hpp).

Экземпляр `Result<T>` гарантированно содержит _либо_ значение типа `T`, _либо_ ошибку.

Пустой `Result` сконструировать невозможно. 

Конструировать экземпляры `Result` нужно либо с помощью статических конструкторов, либо с помощью свободных функций из пространства имен [`make_result`](https://gitlab.com/Lipovsky/wheels/-/blob/master/wheels/result/make.hpp).

[The Error Model](http://joeduffyblog.com/2016/02/07/the-error-model/)

### One-shot

Отправить результат через `Promise` / распаковать `Future` можно _только один раз_.

Чтобы подчеркнуть это ограничение, привяжем к _rvalue_ все методы `Future` / `Promise`, которые приводят к поглощению / отправке результата:

```cpp
// После этого вызова работать с Promise-ом `p` больше нельзя
std::move(p).Set(std::move(result));
```

### `Execute`

С помощью `Future` / `Promise` легко реализовать поверх экзекуторов функциональность возврата значения / ошибки из задачи:

```cpp
executors::ThreadPool pool{4};

// Запускаем вычисление в пуле потоков, 
// получаем экземпляр Future, представляющий результат вычисления
auto f = futures::Execute(pool, []() -> int {
  return 42;
});

// Блокируем поток до завершения вычисления
fmt::println("Value = {}", futures::GetValue(std::move(f)));
```

## Будущий результат

В этой задаче мы перейдем к функциональной трактовке понятия `Future`:

`Future<T>` – _представление_ будущего, еще не готового, результата асинхронной операции.

`Future` может представлять:
* Таймаут
* Вычисление в пуле потоков
* [Remote Procedure Call](http://dist-prog-book.com/chapter/1/rpc.html)
* IO

Такой взгляд на фьючи открывает дорогу к декларативной композиции асинхронных операций: теперь мы
можем оперировать асинхронными операциями как значениями с помощью специальных функций-_комбинаторов_.

## Композиция

### Последовательная композиция

#### `Then`

Будущий результат можно передать в следующую (по цепочке вызовов) функцию, не дожидаясь его готовности:

```cpp
// Запускаем вычисление в пуле потоков
futures::Future<int> f = futures::Execute(pool, []() -> int {
  return 7;
});

// Асинхронно "передаем" будущий результат `f` в продолжение (continuation)
// Продолжение ожидает значения типа T, а не Future<T>
// Связывание происходит внутри комбинатора `Then`
// Then: Future<T> → U(T) → Future<U>
auto g = std::move(f).Then([](int value) {
  return value + 1;
});
```

Переданная в `Then` функция называется _продолжением_ (_continuation_). 

Продолжение получает единственным аргументом значение типа `T` и возвращает новое значение (тип которого будем обозначать через `U`).

Продолжение "поглощает" будущий результат, который представляет фьюча, после вызова `Then` обращаться к исходной фьюче нельзя.

Вызов `Then` – неблокирующий, он не приводит к синхронному ожиданию значения и синхронному вызову продолжения, он _планирует_ вызов продолжения после появления результата в исходной фьюче.

#### Chaining

С помощью `Then` можно [fluently](https://en.wikipedia.org/wiki/Fluent_interface) выстраивать цепочки продолжений произвольной длины:

```cpp
// Стартуем асинхронный конвейер
futures::Execute(pool, []() -> int {
  return 7;
}).Then([](int value) {
  return value + 1;
}).Then([](int value) {
  return value * 2;
}).Subscribe([](wheels::Result<int> result) {
  fmt::println("Value = {}", *result);
});
```

#### Асинхронные продолжения

Продолжение, переданное в `Then`, может быть асинхронным, т.е. возвращать `Future<U>`.

Этот случай требуется обработать отдельно: продолжение, следующее в цепочке за асинхронным продолжением, должно получить на вход не `Future<U>`, а "распакованное" значение типа `U`.

#### Обработка ошибок

Подобно исключениям, ошибка, возникшая на одном из шагов асинхронного конвейера, будет "пролетать" вперед _без вызова_ продолжений:

```cpp
futures::Execute(pool, []() -> int {
  throw std::runtime_error("Fail");
}).Then([](int value) {
  return value + 1;  // Не будет вызван
}).Then([](int value) {
  return value * 2;  // Не будет вызван
}).Subscribe([](wheels::Result<int> result) {
  // result.HasError() == true
});
```

Восстановиться после ошибки можно с помощью комбинатора `Recover`:

```cpp
// Recover: Error → Result<T>

futures::Execute(pool, []() -> int {
  throw std::runtime_error("Fail");
}).Then([](int value) {
  return value + 1;  // Не будет вызван
}).Recover([](wheels::Error /*error*/) {
  // Аналог catch-блока для исключений
  return wheels::make_result::Ok(7); 
}).Subscribe([](wheels::Result<int> result) {
  // result.IsOk() == true
});
```

В отличие от продолжений, которые не вызываются на ошибках, обработчики ошибок симметрично не вызывается на значениях.

#### Функторы и монады

Вариации `Then` связывают вычисления в цепочки: вычисление, представленное в виде `Future<T>`, связывается с продолжением, которое ожидает на вход "распакованное" значение типа `T`.

В обоих случаях у нас есть 
- _контейнер_ для значения и 
- правило _связывания_ вычислений.

Эти точки кастомизации образуют понятие _функтора_ и _монады_, см. [Functors, Applicatives, And Monads In Pictures](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html).

### Параллельная композиция

#### `FirstOf`
```cpp
// std::vector<Future<T>> → Future<T>
// Дожидаемся первого из двух результатов
auto first_of = FirstOf(std::move(f1), std::move(f2))
```

#### `All`

```cpp
// std::vector<Future<T>> → Future<std::vector<T>>
// Параллельно дожидаемся завершения всех асинхронных операций
auto all = All(std::move(f1), std::move(f2), std::move(f3));
```

### Your Server as a Function

- _Фьючи_ + язык _комбинаторов_, 
- _сервисы_ (функции, порождающие фьючи, например, RPC), и 
- _декораторы_ (например, _timeouts_, _retries_, _circuit breakers_, etc)

составляют модель программирования, в которой можно _декларативно_ описывать
целые графы обработки пользовательских запросов, которые будут конкурентно исполняться в общем пуле потоков.

Декларативный стиль скрывает от пользователя всю внутреннюю машинерию, все `Promise`-ы, всю синхронизацию, переводя фокус с _control flow_ на _data flow_.

- [Your Server as a Function](https://monkey.org/~marius/funsrv.pdf)
- [Finagle – Concurrent Programming with Futures](https://twitter.github.io/finagle/guide/Futures.html)

### Файберы и фьючи

Фьючи позволяют декларативно описывать цепочки асинхронных операций с помощью `Then` и обрабатывать в них ошибки с помощью `Recover`.

Но легко заметить, что с последовательной композицией асинхронных операций гораздо лучше справляются файберы:
- Последовательные шаги гораздо проще описывать не на языке комбинаторов, а непосредственно на языке программирования, используя обычные синхронные вызовы и исключения.
- Кроме того, декларативность языка комбинаторов становится препятствием, когда требуется выразить простые императивные конструкции: циклы и ветвления.

С другой стороны, файберы плохо справляются с параллельной композицией, и тут декларативный язык комбинаторов `All` и `FirstOf` оказывается более выразительным.

Делаем вывод: файберы и фьючи – не исключающие друг друга альтернативы, а равноправные инструменты, которые следует комбинировать друг с другом для максимальной выразительности кода.

## Реализация

### `Subscribe`

Внутренняя механика любых комбинаторов – _коллбэки_:

```cpp
futures::Future<int> f = futures::Execute(pool, []() -> int {
  return 7;
});

// Подписываемся на результат фьючи, асинхронно "поглощаем" результат
// Вызов `Subscribe` завершается без блокировки, не дожидаясь вызова коллбэка
std::move(f).Subscribe([](wheels::Result<int> result) {
  if (result.IsOk()) {
    fmt::println("Value = {}", *result);
  } else {
    fmt::println("Computation failed");
  }
}
```

### Примеры коллбэков

Как правило, пользователи фьюч не вызывают `Subscribe` напрямую, а используют более высокоуровневые операции, которые уже в своей реализации подвешивают к фьючам служебные коллбэки:

#### `Then`

```cpp
// Подписываемся на результат, в коллбэке запускаем функцию-продолжение
// и пробрасываем новый результат вперед по цепочке
auto g = std::move(f).Then([](Widget widget) {
  // ...
});
```

#### Синхронное ожидание

```cpp
// Распаковываем фьючу в файбере:
// 1) Останавливаем текущий файбер и 
// 2) подписываемся на готовность фьючи, в коллбэке возобновляем остановленный файбер
auto result = fibers::Await(std::move(future));
```

Аналогично для stackless корутин: `co_await std::move(future)`

### Non-blocking

Обратите внимание: у `Future` нет методов, которые блокировали бы поток!

Фьючи – _неблокирующие_, они реагируют на события: при получении результата фьюча запускает коллбэк, т.е. следующий шаг в цепочке вычислений / следующую асинхронную операцию / возобновляет ждущий ее файбер или корутину.

Поэтому в реализации `Future` / `Promise` не должно быть блокирующих поток примитивов синхронизации, не должно быть взаимного исключения. 

Для синхронизации продьюсера и консьюмера (такой сценарий синхронизации называется _рандеву_) можно реализовать
простой wait-free автомат. См. [автомат в фьючах из `folly`](https://github.com/facebook/folly/blob/e9a24429e17e85539143fb4192d22ac89f012906/folly/futures/detail/Core.h#L247).

Если пользователю все же потребовалось дождаться фьючи с блокировкой потока, то он может воспользоваться внешней функцией [`GetResult`](exe/futures/util/get.hpp), которая реализуется через `Subscribe`.

## Исполнение

### Гонка

Рассмотрим пример:

```cpp
executors::ThreadPool pool{4};

auto [f, p] = futures::MakeContract<int>();

executors::Execute(pool, [p = std::move(p)]() mutable {
  std::move(p).SetValue(42);  // <-- Поток T': отправляем значение
});

std::move(f).Subscribe([](wheels::Result<T> result) {  // <-- Поток T: подвешиваем коллбэк
  fmt::println("Value = {}", *result);
});
```

Вызовы `Subscribe` и `SetValue` "гоняются" друг с другом: неизвестно, что случится раньше – установка коллбэка в потоке _T_ или отправка значения в потоке _T'_. 

От порядка этих вызовов зависит в каком из двух потоков будет вызван подвешенный через `Subscribe` коллбэк.

### Экзекуторы и `Via`

Пользователь, планирующий с помощью фьюч цепочку асинхронных действий, должен иметь контроль на тем, в каких потоках будут выполняться все шаги этой цепочки. И здесь ему на помощь приходят _экзекуторы_.

Продолжение (или коллбэк) можно запланировать на запуск в конкретном экзекуторе с помощью метода `Via`:

```cpp
std::move(f).Via(pool).Subscribe([](wheels::Result<Widget> result) {
  // Обработчик будет вызван в пуле потоков `pool`
});
```

Установленный через `Via` экзекутор наследуется по всей цепочке продолжений:
```cpp
// Вызовы `a` → `b` → `c` будут исполняться экзекутором `e1`
// Вызовы `d` → `last` будут выполнены в экзекуторе `e2`
std::move(f)
  .Via(e1).Then(a).Then(b).Then(c)
  .Via(e2).Then(d).Subsribe(last);
```

#### Typestate Correctness

API фьюч можно усовершенствовать: статически запретить "передавать" фьючу в следующей по цепочке вызов без явного указания экзекутора.

В [Folly/Futures](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md) фьюча может принимать две формы:

* `Future<T>` – фьюча, которая уже ассоциирована с экзекутором, ее можно связать с продолжением
* `SemiFuture<T>` – фьюча, с которой можно работать только синхронно _либо_ трансформировать ее в `Future<T>` с помощью `Via`

[Future vs. SemiFuture](https://github.com/facebook/folly/blob/e270048526d5c65f6dcba13c6e1d5045398847de/folly/futures/Future.h#L466)

## Интрузивность

Поддержите в `Future` интрузивные коллбэки:

```cpp
template <typename T>
struct ICallback {
  virtual void Invoke(wheels::Result<T>) noexcept = 0;
};
```

С помощью интрузивности можно избежать дополнительных аллокаций памяти при синхронной распаковке `Future` в потоках / файберах / корутинах:
- `futures::GetResult(std::move(f))`
- `fibers::Await(std::move(f))`
- `co_await std::move(f)`

## References

### _Finagle_

- [Your Server as a Function](https://monkey.org/~marius/funsrv.pdf)
- [Finagle – Concurrent Programming with Futures](https://twitter.github.io/finagle/guide/Futures.html)
- [Futures: Twitter vs Scala](https://www.youtube.com/watch?v=jiYe-LdPrS0)

### Scala Futures

- [Scala Futures](https://docs.scala-lang.org/overviews/scala-book/futures.html)
- [`scala.concurrent.Future`](https://www.scala-lang.org/api/current/scala/concurrent/Future.html)

### _Folly_

- [Futures for C++11 at Facebook](https://engineering.fb.com/developer-tools/futures-for-c-11-at-facebook/)
- [Folly Futures](https://github.com/facebook/folly/blob/master/folly/docs/Futures.md)

## Задание

1) Реализуйте неблокирующие методы у `Future` / `Promise`
2) Реализуйте [`Execute`](exe/futures/util/execute.hpp)
3) Реализуйте `Subscribe`
4) Реализуйте комбинаторы `Then` и `Recover`
5) Реализуйте комбинаторы [`All`](exe/futures/combine/all.hpp) и [`FirstOf`](exe/futures/combine/first_of.hpp)

## Замечания по реализации

Вместо специализации для `void` предлагается работать с `Future<Unit>`. Тип `void` не подходит для функциональной композиции и нарушает регулярность интерфейсов.

В реализации будет много служебных лямбд-замыканий, которые захватывают `Promise`-ы. Маркируйте такие лямбды как `mutable`.

Перемещайте, а не копируйте `Result<T>` в шаблонном коде, тип `T` может не поддерживать копирование.

Если вам нужно вызвать функцию и завернуть ее возвращаемое значение / исключение в `Result`, то используйте `wheels::make_result::Invoke`.

Избегайте дублирования кода в комбинаторах: общую логику поместите в функцию [`Combine`](exe/futures/combine/detail/combine.hpp), специфичную для комбинатора – в соответствующий класс-комбинатор.

Не пишите в заголовочных файлах (не важно, `.hpp` или `.ipp`) глобальные `using`-и.
