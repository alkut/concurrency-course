# Мьютекс

## Пререквизиты

- [fibers/yield](/tasks/fibers/coroutine)
- [fibers/sleep_for](/tasks/fibers/sleep_for)
- [cond/condvar](/tasks/cond/condvar)
- [cond/wg](tasks/cond/wg)
- *[tasks/executors](/tasks/tasks/executors)

---

Реализуйте примитивы синхронизации для файберов:
- [`Event`](exe/fibers/sync/event.hpp)
- [`Mutex`](exe/fibers/sync/mutex.hpp)
- [`WaitGroup`](exe/fibers/sync/wait_group.hpp)

Методы `Event::Wait`, `Mutex::Lock` и `WaitGroup::Wait` должны останавливать файбер, но не должны блокировать поток планировщика, в котором этот файбер исполняется.

## Пример

```cpp
void SyncExample() {
  using namespace exe;
  
  executors::ThreadPool scheduler{/*threads=*/4};
  scheduler.Start();
  
  fibers::Go(scheduler, []() {
    fibers::Mutex mutex;
    size_t cs = 0;
    
    // https://gobyexample.com/waitgroups
    // Будем считать, что WaitGroup одноразовый, т.е. счетчик
    // опускается до нуля только один раз.
    fibers::WaitGroup wg;
    
    wg.Add(123);
    
    for (size_t i = 0; i < 123; ++i) {
      fibers::Go([&]() {
        // При выходе из скоупа будет вызван wg.Done()
        // https://gobyexample.com/defer
        wheels::Defer defer([&wg]() {
          wg.Done();
        });
        
        for (size_t j = 0; j < 1024; ++j) {
          std::lock_guard guard(mutex);
          ++cs;  // <-- в критической секции
        }
      });
    }
    
    // Дожидаемся завершения всех запущенных выше файберов
    wg.Wait();
    
    fmt::println("# critical sections: {}", cs);
    // <-- Напечатано 123 * 1024
  });
  
  scheduler.WaitIdle();
  scheduler.Stop();
}
```

## `Suspend`

Блокировка файбера на примитиве синхронизации на основе фьютекса – лишь частный случай общей задачи: файберу нужно остановиться и запланировать свое возобновление.
 
Примеры:
- `Mutex::Lock`: запланировать возобновление – значит положить себя в очередь ожидания, из которой нас потом достанут и запустят в вызове `Unlock`.
- `Yield`: сразу же запланировать себя в планировщик
- `Await(Future)`: запланировать возобновление – значит подписаться на готовность `Future` и запустить себя при получении результата.
- [`Select`](/tasks/fibers/channel) на каналах

### Универсальность

В этой задаче мы хотим придумать универсальный `Suspend`, который подойдет для всех перечисленных выше применений.

Файбер не должен знать про конкретные примитивы синхронизации и блокирующие операции, которые с ним работают, про детали их реализации (например, про спинлок фьютекса).

### Awaiters

Решение – кастомизировать для `Suspend` планирование возобновления файбера с помощью внешней (по отношению к файберу) стратегии, которую определяет конкретный примитив синхронизации / операция.

Эту стратегию мы назовем _Awaiter_.

_Awaiter_ в методе `AwaitSuspend` решает когда именно уже **остановленный** файбер должен возобновить свое исполнение.

[Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

### `FiberHandle`

Awaiter работает с остановленным файбером не напрямую, а через объект [`FiberHandle`](exe/fibers/core/handle.hpp).

Непрозрачный `FiberHandle` позволит избавиться в реализации примитивов синхронизации от непосредственного доступа к объекту `Fiber`, скрыть его от пользователя.

## `Yield`

Выразите `Yield` через `Suspend`. 

В классе `Fiber` не должно быть никаких следов `Yield`.

Так вы убедитесь, что получившийся `Suspend` подходит для разных задач синхронизации.

## Аллокации

### `Suspend`

Метод `Yield`, реализованный через `Suspend`, должен обходиться без динамических аллокаций памяти.

Заворачивание лямбды в `std::function` или подобный контейнер с type erasure – тоже динамическая аллокация.

### `Mutex`

В реализации `Mutex`, `Event` и `WaitGroup` не должно быть динамических аллокаций памяти.

Используйте интрузивные списки (в виде [`wheels::IntrusiveList`](https://gitlab.com/Lipovsky/wheels/-/tree/master/wheels/intrusive/list.hpp) или, возможно, вам придется написать что-то своими руками).

### Задачи

Бонусный уровень!

Реализуйте экзекуторы с интрузивными задачами и перенесите их сюда.

### Итого

Если ваша реализация планировщика поддерживает интрузивные задачи, то единственными динамическими аллокациями в рантайме файберов окажутся аллокации самого объекта `Fiber`.

## Синхронизация

### Гонка

Во всех этих примерах есть потенциальная гонка между возобновлением файбера и его остановкой.

При этом в самом классе `Fiber` не должно быть дополнительной синхронизации: ни взаимного исключения, ни ожидания других потоков.

### Lock-free

Бонусный уровень!

Реализуйте примитивы синхронизации без использования взаимного исключения, используя только лок-фри синхронизацию!

## Misc

Не меняйте API пула потоков, файберы для планирования полагаются только на метод `Submit`.

Не делайте `FiberHandle` узлом интрузивного списка. Интрузивный список – это деталь реализации фьютекса, и будет странно, если она проникнет в реализацию `Yield`.

`FiberHandle` – _TriviallyCopyable_, передавайте его по значению.