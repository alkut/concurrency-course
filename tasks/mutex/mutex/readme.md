# Мьютекс

В этой задаче вы должны реализовать [std::mutex](https://ru.cppreference.com/w/cpp/thread/mutex).

Отличие _мьютекса_ от _спинлока_ проявляется в ситуации _contention_, когда сразу несколько потоков конкурируют за владение блокировкой: 

- В _мьютексе_ ждущий поток _блокируется_ (_blocking_) в системной очереди ожидания, на время ожидания он уходит с ядра процессора,
- В _спинлоке_ ждущий поток _кружиться_ (_spinning_) на ядре.

## Futex

Блокировка пользователя реализуется в ядре операционной системы, остановить / запланировать поток может только _планировщик_ ОС.

Для блокировок операционная система (точнее, _Linux_) предоставляет пользователю специальный механизм – _futex_.

Futex – ядерная очередь спящих потоков, которая привязана к ячейке памяти в адресном пространстве пользователя.

Пользователь работает с фьютексом через одноименный системный вызов – [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html).

Обратите внимание: `futex` работает только с 32-битными словами.

### References

- [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html)
- [kernel/futex/waitwake.c](https://github.com/torvalds/linux/blob/master/kernel/futex/waitwake.c)
- [Basics of Futexes](https://eli.thegreenplace.net/2018/basics-of-futexes/)

### Гарантии

Конкурирующие вызовы системного вызова `futex` будут атомарны относительно друг друга: в ядре при работе с очередью фьютекса берется спинлок.

При этом вызов `futex` в режиме ожидания не будет атомарным относительно внешних записей в ячейку памяти: запись может выполниться между чтением значения и парковкой потока в системном вызове.

Прочтите [Basic futex operation and ordering guarantees](https://github.com/torvalds/linux/blob/master/kernel/futex/waitwake.c) из ядра _Linux_, это **единственный** надежный способ разобраться в гарантиях `futex`.


## Twist-ed `Wait`

Мы будем работать с системным механизмом ожидания не напрямую через системные вызовы, а через API `twist/ed/wait/sys.hpp`:

- [API](https://gitlab.com/Lipovsky/twist/-/blob/master/docs/ru/guide.md#wait)
- [Пример использования](https://gitlab.com/Lipovsky/twist/-/blob/master/examples/wait/main.cpp)

### Отличия от `futex`

`Wait` оборачивает вызов `futex` в цикл с перепроверкой условия:

```cpp
void Wait(atomic<uint32_t>& atom, uint32_t old) {
  while (atom.load() == old) {
    FutexWait(Addr(atom), old);
  }
}
```

`Wake` двухфазный: 

1) Сначала (обязательно _до_ записи в атомик, которая предшествует пробуждению) с помощью `PrepareWake` фиксируется ключ для адресации системной очереди ожидания (фактически – адрес ячейки памяти) для атомика:

```cpp
WakeKey PrepareWake(atomic<uint32_t>& atom) {
  return {Addr(atom)};
}
````

2) Затем (_после_ записи в атомик) вызывается `futex` с адресом, который был взят на первом шаге:

```cpp
void WakeOne(WakeKey key) {
  FutexWake(key.addr, 1);
}
```

### Ограничения

Фьютекс работает только с 32-битными словами в пространстве пользователя, так что `Wait` поддерживает только `atomic<uint32_t>`.


## Требования к реализации

* Если поток не может захватить блокировку, потому что его опережают другие потоки, то он должен _заблокироваться_ до освобождения мьютекса и освободить процессор.
* Если же contention-а нет, то захват и освобождение мьютекса должны выполняться без переключения в ядро операционной системы.
