# Взаимная блокировка

- _The plural of "index" is "indices"_
- _The plural of "vertex" is "vertices"_
- _The plural of "mutex" is "deadlock"_

---

В этой задаче вам нужно воспроизвести самый известный многопоточный баг – *взаимную блокировку* или *дэдлок* (*deadlock*).

Назовем *взаимной блокировкой* такое состояние исполнения, в котором ни один из потоков не может продолжить работу независимо от дальнейшего поведения планировщика, поскольку каждый поток заблокировался на ожидании другого.

Дэдлок – терминальная конфигурация, выйти из него нельзя. В этом его отличие от *лайвлока* (*livelock*), который разрешится сам по себе при удачном планировании потоков.

## Кооперативные файберы

Воспроизводить многопоточные баги сложно:
- Невозможно точно предсказать, когда планировщик операционной системы захочет снять текущий поток с процессора
- *Вытеснение* (*preemption*) происходит незаметно для потока, он даже не узнает о том, что бы прерван

Чтобы преодолеть эти сложности, мы будем пользоваться специальными *кооперативными* потоками – [*файберами*](https://gitlab.com/Lipovsky/tinyfibers).

Планировщик файберов реализован в пространстве пользователя и **детерминированно** планирует файберы в одном потоке операционной системы.

Кооперативные файберы отдают управление планировщику только добровольно и явно:
- При вызове `self::Yield()` или `self::SleepFor(delay)`
- При вызове `mutex.Lock()` на [мьютексе](https://en.cppreference.com/w/cpp/thread/mutex), которым в данный момент владеет другой файбер

Планировщик не может остановить бегущий файбер и заменить его другим по собственной воле.

Семантика вызова `self::Yield()` – уступить управление следующему в очереди на исполнение файберу, а самому переместиться в конец очереди.

## Моделирование

Используя файберы, мы можем выстраивать детерминированные конкурентные исполнения, управляя переключениями с помощью вызовов `self::Yield()`.

Суть взаимной блокировки от замены потоков на файберы не меняется.

## Задача

Для начала разберитесь, как ведут себя файберы из [_TinyFibers_](https://gitlab.com/Lipovsky/tinyfibers): изучите примеры, API, напишите собственный код в [`play/main.cpp`](https://gitlab.com/Lipovsky/tinyfibers/-/blob/master/play/main.cpp).

Затем научитесь заводить файберы в дэдлок. Для этого заполните в [`simulation.cpp`](simulation.cpp) лямбды с комментарием
```cpp
// Your code goes here
```

Запускать новые файберы не нужно.

## Блокировки и драконы

Если вам понравилось управлять планировщиком и ломать многопоточный код, то непременно поиграйте в [Deadlock Empire](https://deadlockempire.github.io/)!
